## API Report File for "@siteimprove/alfa-result"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Equatable } from '@siteimprove/alfa-equatable';
import { Foldable } from '@siteimprove/alfa-foldable';
import { Functor } from '@siteimprove/alfa-functor';
import * as json from '@siteimprove/alfa-json';
import { Mapper } from '@siteimprove/alfa-mapper';
import { Monad } from '@siteimprove/alfa-monad';
import { None } from '@siteimprove/alfa-option';
import { Option as Option_2 } from '@siteimprove/alfa-option';
import { Reducer } from '@siteimprove/alfa-reducer';
import { Serializable } from '@siteimprove/alfa-json';
import { Thunk } from '@siteimprove/alfa-thunk';

// @public (undocumented)
export class Err<E> implements Result<never, E> {
    // (undocumented)
    [Symbol.iterator](): Generator<never, void, unknown>;
    // (undocumented)
    and(): this;
    // (undocumented)
    andThen(): this;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    err(): Option_2<E>;
    // (undocumented)
    flatMap(): this;
    // (undocumented)
    get(): never;
    // (undocumented)
    getErr(): E;
    // (undocumented)
    getOr<U>(value: U): U;
    // (undocumented)
    getOrElse<U>(value: Thunk<U>): U;
    // (undocumented)
    isErr(): this is Err<E>;
    // (undocumented)
    isOk(): this is Ok<never>;
    // (undocumented)
    map(): this;
    // (undocumented)
    mapErr<F>(mapper: Mapper<E, F>): Err<F>;
    // (undocumented)
    mapOrElse<T, U>(ok: Mapper<T, U>, err: Mapper<E, U>): U;
    // (undocumented)
    static of<E>(error: E): Err<E>;
    // (undocumented)
    ok(): None;
    // (undocumented)
    or<U, F>(result: Result<U, F>): Result<U, F>;
    // (undocumented)
    orElse<U, F>(result: Thunk<Result<U, F>>): Result<U, F>;
    // (undocumented)
    reduce<U>(reducer: unknown, accumulator: U): U;
    // (undocumented)
    toJSON(): Err.JSON;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
export namespace Err {
    // (undocumented)
    export function isErr<E>(value: unknown): value is Err<E>;
    // (undocumented)
    export interface JSON {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        error: json.JSON;
        // (undocumented)
        type: "err";
    }
}

// @public (undocumented)
export class Ok<T> implements Result<T, never> {
    // (undocumented)
    [Symbol.iterator](): Generator<T, void, unknown>;
    // (undocumented)
    and<U, F>(result: Result<U, F>): Result<U, F>;
    // (undocumented)
    andThen<U, F>(result: Mapper<T, Result<U, F>>): Result<U, F>;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    err(): None;
    // (undocumented)
    flatMap<U, F>(mapper: Mapper<T, Result<U, F>>): Result<U, F>;
    // (undocumented)
    get(): T;
    // (undocumented)
    getErr(): never;
    // (undocumented)
    getOr(): T;
    // (undocumented)
    getOrElse(): T;
    // (undocumented)
    isErr(): this is Err<never>;
    // (undocumented)
    isOk(): this is Ok<T>;
    // (undocumented)
    map<U>(mapper: Mapper<T, U>): Ok<U>;
    // (undocumented)
    mapErr(): this;
    // (undocumented)
    mapOrElse<E, U>(ok: Mapper<T, U>): U;
    // (undocumented)
    static of<T>(value: T): Ok<T>;
    // (undocumented)
    ok(): Option_2<T>;
    // (undocumented)
    or(): this;
    // (undocumented)
    orElse(): this;
    // (undocumented)
    reduce<U>(reducer: Reducer<T, U>, accumulator: U): U;
    // (undocumented)
    toJSON(): Ok.JSON;
    // (undocumented)
    toString(): string;
    }

// @public (undocumented)
export namespace Ok {
    // (undocumented)
    export function isOk<T>(value: unknown): value is Ok<T>;
    // (undocumented)
    export interface JSON {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        type: "ok";
        // (undocumented)
        value: json.JSON;
    }
}

// @public (undocumented)
export interface Result<T, E = T> extends Monad<T>, Functor<T>, Foldable<T>, Iterable<T>, Equatable, Serializable {
    // (undocumented)
    and<U>(result: Result<U, E>): Result<U, E>;
    // (undocumented)
    andThen<U>(result: Mapper<T, Result<U, E>>): Result<U, E>;
    // (undocumented)
    err(): Option_2<E>;
    // (undocumented)
    flatMap<U>(mapper: Mapper<T, Result<U, E>>): Result<U, E>;
    // (undocumented)
    get(): T;
    // (undocumented)
    getErr(): E;
    // (undocumented)
    getOr<U>(value: U): T | U;
    // (undocumented)
    getOrElse<U>(value: Thunk<U>): T | U;
    // (undocumented)
    isErr(): this is Err<E>;
    // (undocumented)
    isOk(): this is Ok<T>;
    // (undocumented)
    map<U>(mapper: Mapper<T, U>): Result<U, E>;
    // (undocumented)
    mapErr<F>(mapper: Mapper<E, F>): Result<T, F>;
    // (undocumented)
    mapOrElse<U>(ok: Mapper<T, U>, err: Mapper<E, U>): U;
    // (undocumented)
    ok(): Option_2<T>;
    // (undocumented)
    or<F>(result: Result<T, F>): Result<T, F>;
    // (undocumented)
    orElse<F>(result: Thunk<Result<T, F>>): Result<T, F>;
    // (undocumented)
    reduce<U>(reducer: Reducer<T, U>, accumulator: U): U;
    // (undocumented)
    toJSON(): Result.JSON;
}

// @public (undocumented)
export namespace Result {
    // (undocumented)
    export function from<T>(thunk: Thunk<Promise<T>>): Promise<Result<T, unknown>>;
    // (undocumented)
    export function from<T>(thunk: Thunk<T>): Result<T, unknown>;
    // (undocumented)
    export function isResult<T, E>(value: unknown): value is Result<T, E>;
    // (undocumented)
    export type JSON = Ok.JSON | Err.JSON;
    // (undocumented)
    export function of<T, E>(value: T): Result<T, E>;
}


// (No @packageDocumentation comment for this package)

```
