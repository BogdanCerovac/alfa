## API Report File for "@siteimprove/alfa-sequence"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Collection } from '@siteimprove/alfa-collection';
import { Hash } from '@siteimprove/alfa-hash';
import * as json from '@siteimprove/alfa-json';
import { Lazy } from '@siteimprove/alfa-lazy';
import { Map as Map_2 } from '@siteimprove/alfa-map';
import { Mapper } from '@siteimprove/alfa-mapper';
import { Option as Option_2 } from '@siteimprove/alfa-option';
import { Predicate } from '@siteimprove/alfa-predicate';
import { Reducer } from '@siteimprove/alfa-reducer';

// @public (undocumented)
export class Cons<T> implements Sequence<T> {
    // (undocumented)
    [Symbol.iterator](): Iterator<T>;
    // (undocumented)
    append(value: T): Cons<T>;
    // (undocumented)
    apply<U>(mapper: Sequence<Mapper<T, U>>): Sequence<U>;
    // (undocumented)
    concat(iterable: Iterable<T>): Cons<T>;
    // (undocumented)
    count(predicate: Predicate<T, T, [number]>): number;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    every(predicate: Predicate<T, T, [number]>): boolean;
    // (undocumented)
    filter<U extends T>(predicate: Predicate<T, U, [number]>, index?: number): Sequence<U>;
    // (undocumented)
    find<U extends T>(predicate: Predicate<T, U, [number]>): Option_2<U>;
    // (undocumented)
    first(): Option_2<T>;
    // (undocumented)
    flatMap<U>(mapper: Mapper<T, Sequence<U>, [number]>, index?: number): Sequence<U>;
    // (undocumented)
    get(index: number): Option_2<T>;
    // (undocumented)
    groupBy<K>(grouper: Mapper<T, K, [number]>): Map_2<K, Sequence<T>>;
    // (undocumented)
    has(index: number): boolean;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    includes(value: T): boolean;
    // (undocumented)
    insert(index: number, value: T): Cons<T>;
    // (undocumented)
    isEmpty(): this is Sequence<never>;
    // (undocumented)
    iterator(): Iterator<T>;
    // (undocumented)
    join(separator: string): string;
    // (undocumented)
    last(): Option_2<T>;
    // (undocumented)
    map<U>(mapper: Mapper<T, U, [number]>, index?: number): Cons<U>;
    // (undocumented)
    static of<T>(head: T, tail?: Lazy<Sequence<T>>): Cons<T>;
    // (undocumented)
    prepend(value: T): Cons<T>;
    // (undocumented)
    reduce<U>(reducer: Reducer<T, U, [number]>, accumulator: U): U;
    // (undocumented)
    reject(predicate: Predicate<T, T, [number]>): Sequence<T>;
    // (undocumented)
    rest(): Sequence<T>;
    // (undocumented)
    reverse(): Sequence<T>;
    // (undocumented)
    set(index: number, value: T): Cons<T>;
    // (undocumented)
    get size(): number;
    // (undocumented)
    skip(count: number): Sequence<T>;
    // (undocumented)
    skipLast(count: number): Sequence<T>;
    // (undocumented)
    skipUntil(predicate: Predicate<T, T, [number]>): Sequence<T>;
    // (undocumented)
    skipWhile(predicate: Predicate<T, T, [number]>): Sequence<T>;
    // (undocumented)
    slice(start: number, end?: number): Sequence<T>;
    // (undocumented)
    some(predicate: Predicate<T, T, [number]>): boolean;
    // (undocumented)
    take(count: number): Sequence<T>;
    // (undocumented)
    takeLast(count: number): Sequence<T>;
    // (undocumented)
    takeUntil(predicate: Predicate<T, T, [number]>, index?: number): Sequence<T>;
    // (undocumented)
    takeWhile(predicate: Predicate<T, T, [number]>): Sequence<T>;
    // (undocumented)
    toArray(): Array<T>;
    // (undocumented)
    toJSON(): Cons.JSON;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
export namespace Cons {
    // (undocumented)
    export function isCons<T>(value: unknown): value is Cons<T>;
    // (undocumented)
    export type JSON = Array<json.JSON>;
}

// @public (undocumented)
export interface Nil extends Sequence<never> {
}

// @public (undocumented)
export const Nil: Nil;

// @public (undocumented)
export namespace Nil {
    // (undocumented)
    export type JSON = Array<never>;
}

// @public (undocumented)
export interface Sequence<T> extends Collection.Indexed<T> {
    // (undocumented)
    append(value: T): Sequence<T>;
    // (undocumented)
    apply<U>(mapper: Sequence<Mapper<T, U>>): Sequence<U>;
    // (undocumented)
    concat(iterable: Iterable<T>): Sequence<T>;
    // (undocumented)
    count(predicate: Predicate<T, T, [number]>): number;
    // (undocumented)
    every(predicate: Predicate<T, T, [number]>): boolean;
    // (undocumented)
    filter<U extends T>(predicate: Predicate<T, U, [number]>): Sequence<U>;
    // (undocumented)
    find<U extends T>(predicate: Predicate<T, U, [number]>): Option_2<U>;
    // (undocumented)
    first(): Option_2<T>;
    // (undocumented)
    flatMap<U>(mapper: Mapper<T, Sequence<U>, [number]>): Sequence<U>;
    // (undocumented)
    get(index: number): Option_2<T>;
    // (undocumented)
    groupBy<K>(grouper: Mapper<T, K, [number]>): Map_2<K, Sequence<T>>;
    // (undocumented)
    has(index: number): boolean;
    // (undocumented)
    includes(value: T): boolean;
    // (undocumented)
    insert(index: number, value: T): Sequence<T>;
    // (undocumented)
    isEmpty(): this is Sequence<never>;
    // (undocumented)
    join(separator: string): string;
    // (undocumented)
    last(): Option_2<T>;
    // (undocumented)
    map<U>(mapper: Mapper<T, U, [number]>): Sequence<U>;
    // (undocumented)
    prepend(value: T): Sequence<T>;
    // (undocumented)
    reduce<U>(reducer: Reducer<T, U, [number]>, accumulator: U): U;
    // (undocumented)
    reject(predicate: Predicate<T, T, [number]>): Sequence<T>;
    // (undocumented)
    rest(): Sequence<T>;
    // (undocumented)
    reverse(): Sequence<T>;
    // (undocumented)
    set(index: number, value: T): Sequence<T>;
    // (undocumented)
    skip(count: number): Sequence<T>;
    // (undocumented)
    skipLast(count: number): Sequence<T>;
    // (undocumented)
    skipUntil(predicate: Predicate<T, T, [number]>): Sequence<T>;
    // (undocumented)
    skipWhile(predicate: Predicate<T, T, [number]>): Sequence<T>;
    // (undocumented)
    slice(start: number, end?: number): Sequence<T>;
    // (undocumented)
    some(predicate: Predicate<T, T, [number]>): boolean;
    // (undocumented)
    take(count: number): Sequence<T>;
    // (undocumented)
    takeLast(count: number): Sequence<T>;
    // (undocumented)
    takeUntil(predicate: Predicate<T, T, [number]>): Sequence<T>;
    // (undocumented)
    takeWhile(predicate: Predicate<T, T, [number]>): Sequence<T>;
    // (undocumented)
    toArray(): Array<T>;
    // (undocumented)
    toJSON(): Sequence.JSON;
}

// @public (undocumented)
export namespace Sequence {
    // (undocumented)
    export function empty<T>(): Sequence<T>;
    // (undocumented)
    export function flatten<T>(sequence: Sequence<Sequence<T>>): Sequence<T>;
    // (undocumented)
    export function from<T>(iterable: Iterable<T>): Sequence<T>;
    // (undocumented)
    export function fromArray<T>(array: Array<T>): Sequence<T>;
    // (undocumented)
    export function fromIterable<T>(iterable: Iterable<T>): Sequence<T>;
    // (undocumented)
    export function fromIterator<T>(iterator: Iterator<T>): Sequence<T>;
    // (undocumented)
    export function isSequence<T>(value: unknown): value is Sequence<T>;
    // (undocumented)
    export type JSON = Cons.JSON | Nil.JSON;
    // (undocumented)
    export function of<T>(head: T, tail?: Lazy<Sequence<T>>): Sequence<T>;
}


// (No @packageDocumentation comment for this package)

```
