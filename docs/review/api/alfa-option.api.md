## API Report File for "@siteimprove/alfa-option"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Applicative } from '@siteimprove/alfa-applicative';
import { Equatable } from '@siteimprove/alfa-equatable';
import { Foldable } from '@siteimprove/alfa-foldable';
import { Functor } from '@siteimprove/alfa-functor';
import { Hash } from '@siteimprove/alfa-hash';
import { Hashable } from '@siteimprove/alfa-hash';
import * as json from '@siteimprove/alfa-json';
import { Mapper } from '@siteimprove/alfa-mapper';
import { Monad } from '@siteimprove/alfa-monad';
import { Predicate } from '@siteimprove/alfa-predicate';
import { Reducer } from '@siteimprove/alfa-reducer';
import { Serializable } from '@siteimprove/alfa-json';
import { Thunk } from '@siteimprove/alfa-thunk';

// @public (undocumented)
export interface None extends Option_2<never> {
}

// @public (undocumented)
export const None: None;

// @public (undocumented)
export namespace None {
    // (undocumented)
    export interface JSON {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        type: "none";
    }
}

// @public (undocumented)
interface Option_2<T> extends Functor<T>, Monad<T>, Foldable<T>, Applicative<T>, Iterable<T>, Equatable, Hashable, Serializable {
    // (undocumented)
    and<U>(option: Option_2<U>): Option_2<U>;
    // (undocumented)
    andThen<U>(option: Mapper<T, Option_2<U>>): Option_2<U>;
    // (undocumented)
    apply<U>(mapper: Option_2<Mapper<T, U>>): Option_2<U>;
    // (undocumented)
    every(predicate: Predicate<T>): boolean;
    // (undocumented)
    filter<U extends T>(predicate: Predicate<T, U>): Option_2<U>;
    // (undocumented)
    flatMap<U>(mapper: Mapper<T, Option_2<U>>): Option_2<U>;
    // (undocumented)
    get(): T;
    // (undocumented)
    getOr<U>(value: U): T | U;
    // (undocumented)
    getOrElse<U>(value: Thunk<U>): T | U;
    // (undocumented)
    includes(value: T): boolean;
    // (undocumented)
    isNone(): this is None;
    // (undocumented)
    isSome(): this is Some<T>;
    // (undocumented)
    map<U>(mapper: Mapper<T, U>): Option_2<U>;
    // (undocumented)
    or<U>(option: Option_2<U>): Option_2<T | U>;
    // (undocumented)
    orElse<U>(option: Thunk<Option_2<U>>): Option_2<T | U>;
    // (undocumented)
    reduce<U>(reducer: Reducer<T, U>, accumulator: U): U;
    // (undocumented)
    some(predicate: Predicate<T>): boolean;
    // (undocumented)
    toArray(): Array<T>;
    // (undocumented)
    toJSON(): Option_2.JSON;
}

// @public (undocumented)
namespace Option_2 {
    // (undocumented)
    function empty<T>(): Option_2<T>;
    // (undocumented)
    function flatten<T>(option: Option_2<Option_2<T>>): Option_2<T>;
    // (undocumented)
    function from<T>(value: T | null | undefined): Option_2<NonNullable<T>>;
    // (undocumented)
    function isOption<T>(value: unknown): value is Option_2<T>;
    // (undocumented)
    type JSON = Some.JSON | None.JSON;
    // (undocumented)
    type Maybe<T> = T | Option_2<T>;
    // (undocumented)
    function of<T>(value: T): Option_2<T>;
}

export { Option_2 as Option }

// @public (undocumented)
export class Some<T> implements Option_2<T> {
    // (undocumented)
    [Symbol.iterator](): Iterator<T>;
    // (undocumented)
    and<U>(option: Option_2<U>): Option_2<U>;
    // (undocumented)
    andThen<U>(option: Mapper<T, Option_2<U>>): Option_2<U>;
    // (undocumented)
    apply<U>(mapper: Option_2<Mapper<T, U>>): Option_2<U>;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    every(predicate: Predicate<T>): boolean;
    // (undocumented)
    filter<U extends T>(predicate: Predicate<T, U>): Option_2<U>;
    // (undocumented)
    flatMap<U>(mapper: Mapper<T, Option_2<U>>): Option_2<U>;
    // (undocumented)
    get(): T;
    // (undocumented)
    getOr(): T;
    // (undocumented)
    getOrElse(): T;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    includes(value: T): boolean;
    // (undocumented)
    isNone(): this is None;
    // (undocumented)
    isSome(): this is Some<T>;
    // (undocumented)
    map<U>(mapper: Mapper<T, U>): Option_2<U>;
    // (undocumented)
    static of<T>(value: T): Some<T>;
    // (undocumented)
    or(): Option_2<T>;
    // (undocumented)
    orElse(): Option_2<T>;
    // (undocumented)
    reduce<U>(reducer: Reducer<T, U>, accumulator: U): U;
    // (undocumented)
    some(predicate: Predicate<T>): boolean;
    // (undocumented)
    toArray(): [T];
    // (undocumented)
    toJSON(): Some.JSON;
    // (undocumented)
    toString(): string;
    }

// @public (undocumented)
export namespace Some {
    // (undocumented)
    export function isSome<T>(value: unknown): value is Some<T>;
    // (undocumented)
    export interface JSON {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        type: "some";
        // (undocumented)
        value: json.JSON;
    }
}


// (No @packageDocumentation comment for this package)

```
