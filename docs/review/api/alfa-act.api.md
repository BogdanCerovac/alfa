## API Report File for "@siteimprove/alfa-act"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import * as earl from '@siteimprove/alfa-earl';
import { Equatable } from '@siteimprove/alfa-equatable';
import { Functor } from '@siteimprove/alfa-functor';
import { Future } from '@siteimprove/alfa-future';
import { Iterable as Iterable_2 } from '@siteimprove/alfa-iterable';
import * as json from '@siteimprove/alfa-json';
import { Mapper } from '@siteimprove/alfa-mapper';
import { Monad } from '@siteimprove/alfa-monad';
import { Option as Option_2 } from '@siteimprove/alfa-option';
import { Record as Record_2 } from '@siteimprove/alfa-record';
import { Result } from '@siteimprove/alfa-result';
import { Sequence } from '@siteimprove/alfa-sequence';
import { Serializable } from '@siteimprove/alfa-json';
import { Thunk } from '@siteimprove/alfa-thunk';

// @public (undocumented)
export class Audit<I, T = unknown, Q = never> {
    // (undocumented)
    evaluate(): Future<Iterable_2<Outcome<I, T, Q>>>;
    // (undocumented)
    static of<I, T = unknown, Q = never>(input: I, rules: Iterable_2<Rule<I, T, Q>>, oracle?: Oracle<Q>): Audit<I, T, Q>;
    }

// @public (undocumented)
class Cache_2 {
    // (undocumented)
    static empty(): Cache_2;
    // (undocumented)
    get<I, T, Q>(rule: Rule<I, T, Q>, ifMissing: Thunk<Future<Iterable<Outcome<I, T, Q>>>>): Future<Iterable<Outcome<I, T, Q>>>;
    }

export { Cache_2 as Cache }

// @public (undocumented)
export class Diagnostic implements Equatable, Serializable {
    protected constructor(message: string);
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    get message(): string;
    // (undocumented)
    protected readonly _message: string;
    // (undocumented)
    static of(message: string): Diagnostic;
    // (undocumented)
    toJSON(): Diagnostic.JSON;
}

// @public (undocumented)
export namespace Diagnostic {
    // (undocumented)
    export function isDiagnostic(value: unknown): value is Diagnostic;
    // (undocumented)
    export interface JSON {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        message: string;
    }
}

// Warning: (ae-forgotten-export) The symbol "Depths" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type Interview<Q, S, T, D extends number = 3> = T | {
    [K in keyof Q]: Question<K, Q[K], S, D extends -1 ? T : Interview<Q, S, T, Depths[D]>>;
}[keyof Q];

// @public (undocumented)
export namespace Interview {
    // (undocumented)
    export function conduct<I, T, Q, A>(interview: Interview<Q, T, A>, rule: Rule<I, T, Q>, oracle: Oracle<Q>): Future<Option_2<A>>;
}

// @public (undocumented)
export type Oracle<Q> = <I, T, A>(rule: Rule<I, T, Q>, question: {
    [K in keyof Q]: Question<K, Q[K], T, A>;
}[keyof Q]) => Future<Option_2<A>>;

// @public (undocumented)
export abstract class Outcome<I, T, Q = never> implements Equatable, json.Serializable, earl.Serializable {
    protected constructor(rule: Rule<I, T, Q>);
    // (undocumented)
    abstract equals(value: unknown): value is this;
    // (undocumented)
    get rule(): Rule<I, T, Q>;
    // (undocumented)
    protected readonly _rule: Rule<I, T, Q>;
    // (undocumented)
    get target(): T | undefined;
    // (undocumented)
    toEARL(): Outcome.EARL;
    // (undocumented)
    abstract toJSON(): Outcome.JSON;
}

// @public (undocumented)
export namespace Outcome {
    // (undocumented)
    export type Applicable<I, T, Q = unknown> = Passed<I, T, Q> | Failed<I, T, Q> | CantTell<I, T, Q>;
    // (undocumented)
    export class CantTell<I, T, Q = never> extends Outcome<I, T, Q> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        static of<I, T, Q>(rule: Rule<I, T, Q>, target: T): CantTell<I, T, Q>;
        // (undocumented)
        get target(): T;
        // (undocumented)
        toEARL(): CantTell.EARL;
        // (undocumented)
        toJSON(): CantTell.JSON;
    }
    // (undocumented)
    export namespace CantTell {
        // (undocumented)
        export interface EARL extends Outcome.EARL {
            // (undocumented)
            "earl:result": {
                "@type": "earl:TestResult";
                "earl:outcome": {
                    "@id": "earl:cantTell";
                };
            };
        }
        // (undocumented)
        export interface JSON extends Outcome.JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            outcome: "cantTell";
            // (undocumented)
            target: json.JSON;
        }
    }
    // (undocumented)
    export interface EARL extends earl.EARL {
        // (undocumented)
        "@type": "earl:Assertion";
        // (undocumented)
        "earl:test": {
            "@id": string;
        };
    }
    // (undocumented)
    export class Failed<I, T, Q = never> extends Outcome<I, T, Q> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        get expectations(): Record_2<{
            [key: string]: Result<Diagnostic>;
        }>;
        // (undocumented)
        static of<I, T, Q>(rule: Rule<I, T, Q>, target: T, expectations: Record_2<{
            [key: string]: Result<Diagnostic>;
        }>): Failed<I, T, Q>;
        // (undocumented)
        get target(): T;
        // (undocumented)
        toEARL(): Failed.EARL;
        // (undocumented)
        toJSON(): Failed.JSON;
    }
    // (undocumented)
    export namespace Failed {
        // (undocumented)
        export interface EARL extends Outcome.EARL {
            // (undocumented)
            "earl:result": {
                "@type": "earl:TestResult";
                "earl:outcome": {
                    "@id": "earl:failed";
                };
                "earl:info": string;
                "earl:pointer"?: earl.EARL;
            };
        }
        // (undocumented)
        export interface JSON extends Outcome.JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            expectations: Array<[string, Result.JSON]>;
            // (undocumented)
            outcome: "failed";
            // (undocumented)
            target: json.JSON;
        }
    }
    // (undocumented)
    export function from<I, T, Q>(rule: Rule<I, T, Q>, target: T, expectations: Record_2<{
        [key: string]: Option_2<Result<Diagnostic>>;
    }>): Outcome.Applicable<I, T, Q>;
    // (undocumented)
    export class Inapplicable<I, T, Q = unknown> extends Outcome<I, T, Q> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        static of<I, T, Q>(rule: Rule<I, T, Q>): Inapplicable<I, T, Q>;
        // (undocumented)
        toEARL(): Inapplicable.EARL;
        // (undocumented)
        toJSON(): Inapplicable.JSON;
    }
    // (undocumented)
    export namespace Inapplicable {
        // (undocumented)
        export interface EARL extends Outcome.EARL {
            // (undocumented)
            "earl:result": {
                "@type": "earl:TestResult";
                "earl:outcome": {
                    "@id": "earl:inapplicable";
                };
            };
        }
        // (undocumented)
        export interface JSON extends Outcome.JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            outcome: "inapplicable";
        }
    }
    // (undocumented)
    export function isApplicable<I, T, Q>(outcome: Outcome<I, T, Q>): outcome is Applicable<I, T, Q>;
    // (undocumented)
    export function isCantTell<I, T, Q>(outcome: Outcome<I, T, Q>): outcome is CantTell<I, T, Q>;
    // (undocumented)
    export function isFailed<I, T, Q>(outcome: Outcome<I, T, Q>): outcome is Failed<I, T, Q>;
    // (undocumented)
    export function isInapplicable<I, T, Q>(outcome: Outcome<I, T, Q>): outcome is Inapplicable<I, T, Q>;
    // (undocumented)
    export function isPassed<I, T, Q>(outcome: Outcome<I, T, Q>): outcome is Passed<I, T, Q>;
    // (undocumented)
    export interface JSON {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        outcome: string;
        // (undocumented)
        rule: Rule.JSON;
    }
    // (undocumented)
    export class Passed<I, T, Q = never> extends Outcome<I, T, Q> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        get expectations(): Record_2<{
            [key: string]: Result<Diagnostic>;
        }>;
        // (undocumented)
        static of<I, T, Q>(rule: Rule<I, T, Q>, target: T, expectations: Record_2<{
            [key: string]: Result<Diagnostic>;
        }>): Passed<I, T, Q>;
        // (undocumented)
        get target(): T;
        // (undocumented)
        toEARL(): Passed.EARL;
        // (undocumented)
        toJSON(): Passed.JSON;
    }
    // (undocumented)
    export namespace Passed {
        // (undocumented)
        export interface EARL extends Outcome.EARL {
            // (undocumented)
            "earl:result": {
                "@type": "earl:TestResult";
                "earl:outcome": {
                    "@id": "earl:passed";
                };
                "earl:info": string;
                "earl:pointer"?: earl.EARL;
            };
        }
        // (undocumented)
        export interface JSON extends Outcome.JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            expectations: Array<[string, Result.JSON]>;
            // (undocumented)
            outcome: "passed";
            // (undocumented)
            target: json.JSON;
        }
    }
}

// @public (undocumented)
export class Question<Q, A, S, T = A> implements Monad<T>, Functor<T>, Serializable {
    protected constructor(uri: string, type: Q, subject: S, message: string, quester: Mapper<A, T>);
    // (undocumented)
    answer(answer: A): T;
    // (undocumented)
    flatMap<U>(mapper: Mapper<T, Question<Q, A, S, U>>): Question<Q, A, S, U>;
    // (undocumented)
    map<U>(mapper: Mapper<T, U>): Question<Q, A, S, U>;
    // (undocumented)
    get message(): string;
    // (undocumented)
    static of<Q, A, S>(uri: string, type: Q, subject: S, message: string): Question<Q, A, S>;
    // (undocumented)
    get subject(): S;
    // (undocumented)
    toJSON(): Question.JSON;
    // (undocumented)
    get type(): Q;
    // (undocumented)
    get uri(): string;
    }

// @public (undocumented)
export namespace Question {
    // (undocumented)
    export function isQuestion<Q, A, S, T = A>(value: unknown): value is Question<Q, A, S, T>;
    // (undocumented)
    export interface JSON {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        message: string;
        // (undocumented)
        subject: json.JSON;
        // (undocumented)
        type: json.JSON;
        // (undocumented)
        uri: string;
    }
}

// @public (undocumented)
export abstract class Rule<I, T = unknown, Q = never> implements Equatable, json.Serializable, earl.Serializable {
    protected constructor(uri: string, evaluator: Rule.Evaluate<I, T, Q>);
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    evaluate(input: Readonly<I>, oracle?: Oracle<Q>, outcomes?: Cache_2): Future<Iterable_2<Outcome<I, T, Q>>>;
    // (undocumented)
    protected readonly _evaluate: Rule.Evaluate<I, T, Q>;
    // (undocumented)
    toEARL(): Rule.EARL;
    // (undocumented)
    abstract toJSON(): Rule.JSON;
    // (undocumented)
    get uri(): string;
    // (undocumented)
    protected readonly _uri: string;
}

// @public (undocumented)
export namespace Rule {
    // (undocumented)
    export class Atomic<I, T = unknown, Q = never> extends Rule<I, T, Q> {
        // (undocumented)
        static of<I, T = unknown, Q = never>(properties: {
            uri: string;
            evaluate: Atomic.Evaluate<I, T, Q>;
        }): Atomic<I, T, Q>;
        // (undocumented)
        toJSON(): Atomic.JSON;
    }
    // (undocumented)
    export namespace Atomic {
        // (undocumented)
        export interface Evaluate<I, T, Q> {
            // (undocumented)
            (input: Readonly<I>): {
                applicability(): Iterable_2<Interview<Q, T, Option_2.Maybe<T>>>;
                expectations(target: T): {
                    [key: string]: Interview<Q, T, Option_2.Maybe<Result<Diagnostic>>>;
                };
            };
        }
        // (undocumented)
        export interface JSON extends Rule.JSON {
            // (undocumented)
            type: "atomic";
        }
    }
    // (undocumented)
    export class Composite<I, T = unknown, Q = never> extends Rule<I, T, Q> {
        // (undocumented)
        get composes(): Iterable_2<Rule<I, T, Q>>;
        // (undocumented)
        static of<I, T = unknown, Q = never>(properties: {
            uri: string;
            composes: Iterable_2<Rule<I, T, Q>>;
            evaluate: Composite.Evaluate<I, T, Q>;
        }): Composite<I, T, Q>;
        // (undocumented)
        toJSON(): Composite.JSON;
    }
    // (undocumented)
    export namespace Composite {
        // (undocumented)
        export interface Evaluate<I, T, Q> {
            // (undocumented)
            (input: Readonly<I>): {
                expectations(outcomes: Sequence<Outcome.Applicable<I, T, Q>>): {
                    [key: string]: Interview<Q, T, Option_2.Maybe<Result<Diagnostic>>>;
                };
            };
        }
        // (undocumented)
        export interface JSON extends Rule.JSON {
            // (undocumented)
            composes: Array<Rule.JSON>;
            // (undocumented)
            type: "composite";
            // (undocumented)
            uri: string;
        }
    }
    // (undocumented)
    export interface EARL extends earl.EARL {
        // (undocumented)
        "@id": string;
        // (undocumented)
        "@type": ["earl:TestCriterion", "earl:TestCase"];
    }
    export interface Evaluate<I, T, Q> {
        // (undocumented)
        (input: Readonly<I>, oracle: Oracle<Q>, outcomes: Cache_2): Future<Iterable_2<Outcome<I, T, Q>>>;
    }
    // (undocumented)
    export type Input<R> = R extends Rule<infer I, any, any> ? I : never;
    // (undocumented)
    export function isAtomic<I, T, Q>(value: unknown): value is Atomic<I, T, Q>;
    // (undocumented)
    export function isComposite<I, T, Q>(value: unknown): value is Composite<I, T, Q>;
    // (undocumented)
    export function isRule<I, T, Q>(value: unknown): value is Rule<I, T, Q>;
    // (undocumented)
    export interface JSON {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        type: string;
        // (undocumented)
        uri: string;
    }
    // (undocumented)
    export type Question<R> = R extends Rule<any, any, infer Q> ? Q : never;
    // (undocumented)
    export type Target<R> = R extends Rule<any, infer T, any> ? T : never;
}


// (No @packageDocumentation comment for this package)

```
