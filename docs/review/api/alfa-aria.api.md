## API Report File for "@siteimprove/alfa-aria"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Branched } from '@siteimprove/alfa-branched';
import { Browser } from '@siteimprove/alfa-compatibility';
import { Device } from '@siteimprove/alfa-device';
import * as dom from '@siteimprove/alfa-dom';
import { Element as Element_2 } from '@siteimprove/alfa-dom';
import { Equatable } from '@siteimprove/alfa-equatable';
import { Iterable as Iterable_2 } from '@siteimprove/alfa-iterable';
import * as json from '@siteimprove/alfa-json';
import { Map as Map_2 } from '@siteimprove/alfa-map';
import { Mapper } from '@siteimprove/alfa-mapper';
import { Namespace } from '@siteimprove/alfa-dom';
import { Option as Option_2 } from '@siteimprove/alfa-option';
import { Predicate } from '@siteimprove/alfa-predicate';
import { Sequence } from '@siteimprove/alfa-sequence';
import { Serializable } from '@siteimprove/alfa-json';

// @public (undocumented)
export class Attribute<N extends string = string> implements Equatable {
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    readonly implicit: Option_2<string>;
    // (undocumented)
    isValid(value: string): boolean;
    // (undocumented)
    readonly name: N;
    // (undocumented)
    static of<N extends string>(name: N, type: Attribute.Type, value: Attribute.Value, valid?: Option_2<Iterable_2<string>>, implicit?: Option_2<string>, status?: Attribute.Status): Attribute<N>;
    // (undocumented)
    readonly status: Attribute.Status;
    // (undocumented)
    readonly type: Attribute.Type;
    // (undocumented)
    readonly valid: Option_2<Iterable_2<string>>;
    // (undocumented)
    readonly value: Attribute.Value;
}

// @public (undocumented)
export namespace Attribute {
    // (undocumented)
    export function lookup<N extends string>(name: N): Option_2<Attribute<N>>;
    // (undocumented)
    export function register<N extends string>(attribute: Attribute<N>): Attribute<N>;
    // (undocumented)
    export interface Status {
        // (undocumented)
        readonly deprecated: boolean;
    }
    // (undocumented)
    export enum Type {
        Property = "property",
        State = "state"
    }
    // (undocumented)
    export type Value =
    /**
     * @see https://www.w3.org/TR/wai-aria/#valuetype_true-false
     */
    "true-false"
    /**
     * @see https://www.w3.org/TR/wai-aria/#valuetype_true-false-undefined
     */
     | "true-false-undefined"
    /**
     * @see https://www.w3.org/TR/wai-aria/#valuetype_tristate
     */
     | "tristate"
    /**
     * @see https://www.w3.org/TR/wai-aria/#valuetype_idref
     */
     | "id-reference"
    /**
     * @see https://www.w3.org/TR/wai-aria/#valuetype_idref_list
     */
     | "id-reference-list"
    /**
     * @see https://www.w3.org/TR/wai-aria/#valuetype_integer
     */
     | "integer"
    /**
     * @see https://www.w3.org/TR/wai-aria/#valuetype_number
     */
     | "number"
    /**
     * @see https://www.w3.org/TR/wai-aria/#valuetype_string
     */
     | "string"
    /**
     * @see https://www.w3.org/TR/wai-aria/#valuetype_token
     */
     | "token"
    /**
     * @see https://www.w3.org/TR/wai-aria/#valuetype_token_list
     */
     | "token-list"
    /**
     * @see https://www.w3.org/TR/wai-aria/#valuetype_uri
     */
     | "uri";
}

// @public (undocumented)
export class Feature<N extends string = string> {
    // (undocumented)
    get attributes(): Feature.Aspect<Map_2<string, string>>;
    // (undocumented)
    get name(): N;
    // (undocumented)
    static of<N extends string>(name: N, role?: Feature.Aspect<Option_2<string>, [Feature.RoleOptions]>, attributes?: Feature.Aspect<Map_2<string, string>>, status?: Feature.Status): Feature<N>;
    // (undocumented)
    get role(): Feature.Aspect<Option_2<string>, [Feature.RoleOptions]>;
    // (undocumented)
    get status(): Feature.Status;
    }

// @public (undocumented)
export namespace Feature {
    // (undocumented)
    export type Aspect<T, A extends Array<unknown> = []> = Mapper<Element_2, T, A>;
    // (undocumented)
    export function lookup<N extends string>(namespace: Namespace, name: N): Option_2<Feature<N>>;
    // (undocumented)
    export function register<N extends string>(namespace: Namespace, feature: Feature<N>): Feature<N>;
    // (undocumented)
    export interface RoleOptions {
        // @internal (undocumented)
        readonly allowPresentational?: boolean;
    }
    // (undocumented)
    export interface Status {
        // (undocumented)
        readonly obsolete: boolean;
    }
}

// @public
abstract class Node_2 implements Serializable {
    protected constructor(owner: dom.Node, children: Mapper<Node_2, Iterable_2<Node_2>>, parent: Option_2<Node_2>);
    // @internal (undocumented)
    adopt(children: Iterable_2<Node_2>): this;
    ancestors(options?: Node_2.Traversal): Sequence<Node_2>;
    // (undocumented)
    abstract attribute(name: string): Option_2<string>;
    children(options?: Node_2.Traversal): Sequence<Node_2>;
    // (undocumented)
    protected _children: Array<Node_2>;
    // (undocumented)
    abstract clone(parent?: Option_2<Node_2>): Node_2;
    descendants(options?: Node_2.Traversal): Sequence<Node_2>;
    // (undocumented)
    abstract isIgnored(): boolean;
    // (undocumented)
    abstract name(): Option_2<string>;
    // (undocumented)
    get node(): dom.Node;
    // (undocumented)
    protected readonly _node: dom.Node;
    parent(options?: Node_2.Traversal): Option_2<Node_2>;
    // (undocumented)
    protected _parent: Option_2<Node_2>;
    // (undocumented)
    abstract role(): Option_2<Role>;
    root(options?: Node_2.Traversal): Node_2;
    // (undocumented)
    abstract toJSON(): Node_2.JSON;
}

// @public (undocumented)
namespace Node_2 {
    // (undocumented)
    function from(node: dom.Node, device: Device): Branched<Node_2, Browser>;
    // (undocumented)
    interface JSON {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        children: Array<JSON>;
        // (undocumented)
        node: dom.Node.JSON;
        // (undocumented)
        type: string;
    }
    // (undocumented)
    interface Traversal {
        readonly ignored?: boolean;
    }
}

export { Node_2 as Node }

// @public (undocumented)
export class Role<N extends string = string> implements Equatable {
    // (undocumented)
    readonly category: Role.Category;
    // (undocumented)
    readonly characteristics: Role.Characteristics;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hasContext(predicate?: Predicate<Role>): boolean;
    // (undocumented)
    hasName(predicate: Predicate<string>): boolean;
    // (undocumented)
    hasNameFrom(predicate: Predicate<"contents" | "author">): boolean;
    // (undocumented)
    inheritsFrom(predicate: Predicate<Role>): boolean;
    // (undocumented)
    isAllowed(predicate: Predicate<Attribute>): boolean;
    // (undocumented)
    isRequired(predicate: Predicate<Attribute>): boolean;
    // (undocumented)
    isSupported(predicate: Predicate<Attribute>): boolean;
    // (undocumented)
    readonly name: N;
    // (undocumented)
    static of<N extends string>(name: N, category: Role.Category, characteristics?: Partial<Role.Characteristics>): Role<N>;
    // (undocumented)
    required(): Iterable_2<Attribute>;
    // (undocumented)
    supported(): Iterable_2<Attribute>;
    // (undocumented)
    toJSON(): {
        name: N;
        category: Role.Category;
        characteristics: Role.Characteristics;
    };
}

// @public (undocumented)
export namespace Role {
    export enum Category {
        Abstract = "abstract",
        Graphic = "graphic",
        Landmark = "landmark",
        LiveRegion = "live-region",
        Structure = "structure",
        Widget = "widget",
        Window = "window"
    }
    // (undocumented)
    export interface Characteristics {
        readonly context: Iterable_2<string>;
        readonly implicits: Iterable_2<readonly [string, string]>;
        readonly inherits: Iterable_2<string>;
        readonly name: {
            readonly from: Readonly<Array<"contents" | "author">>;
            readonly required: boolean;
        };
        readonly owns: Iterable_2<string | readonly [string, string, ...Array<string>]>;
        readonly presentational: boolean;
        readonly requires: Iterable_2<string>;
        readonly supports: Iterable_2<string>;
    }
    export function from(element: Element_2, options?: from.Options): Branched<Option_2<Role>, Browser>;
    // (undocumented)
    export namespace from {
        // (undocumented)
        export interface Options extends Partial<Feature.RoleOptions> {
            // (undocumented)
            readonly explicit?: boolean;
            // (undocumented)
            readonly implicit?: boolean;
        }
    }
    // (undocumented)
    export function hasName(predicate: Predicate<string>): Predicate<Role>;
    // (undocumented)
    export function hasName(name: string, ...rest: Array<string>): Predicate<Role>;
    const // (undocumented)
    isPresentational: Predicate<Role<string>, Role<string>, []>;
    // (undocumented)
    export function lookup<N extends string>(name: N): Option_2<Role<N>>;
    // (undocumented)
    export function register<N extends string>(role: Role<N>): Role<N>;
}


// (No @packageDocumentation comment for this package)

```
