import { Node } from "./types";
import { isParent, isChild } from "./guards";

export type Predicate<T, U extends T> =
  | ((n: T) => boolean)
  | ((n: T) => n is U);

export class CollectorIterator<T extends Node> implements Iterator<T> {
  private readonly queue: Array<Node> = [];

  private readonly predicate: Predicate<Node, T>;

  constructor(context: Node, predicate: Predicate<Node, T>) {
    this.queue.push(context);
    this.predicate = predicate;
  }

  public next(): IteratorResult<T> {
    const next = this.queue.pop();

    if (next === undefined) {
      // https://github.com/Microsoft/TypeScript/issues/8938
      return { done: true } as IteratorResult<T>;
    }

    if (isParent(next)) {
      const { childNodes } = next;

      for (let i = childNodes.length - 1; i >= 0; i--) {
        this.queue.push(childNodes[i]);
      }
    }

    if (this.predicate(next)) {
      return { done: false, value: next };
    }

    return this.next();
  }
}

export class Collector<T extends Node> implements Iterable<T> {
  /**
   * The context on which the collector operates. This is used as the root node
   * during iteration.
   */
  private readonly context: Node;

  /**
   * The predicate that determines the nodes generated by the collector. All
   * nodes that match this predicate will be yielded during iteration.
   */
  private readonly predicate: Predicate<Node, T>;

  constructor(context: Node, predicate: Predicate<Node, T> = () => true) {
    this.context = context;
    this.predicate = predicate;
  }

  public where<U extends T>(predicate: Predicate<T, U>): Collector<U> {
    return new Collector<U>(
      this.context,
      n => this.predicate(n) && predicate(n as T)
    );
  }

  public first(): T | null {
    const iterator = this.values();

    for (let next = iterator.next(); !next.done; ) {
      return next.value;
    }

    return null;
  }

  public last(): T | null {
    const iterator = this.values();

    let last: T | null = null;

    for (let next = iterator.next(); !next.done; next = iterator.next()) {
      last = next.value;
    }

    return last;
  }

  public values(): Iterator<T> {
    return new CollectorIterator(this.context, this.predicate);
  }

  public [Symbol.iterator](): Iterator<T> {
    return this.values();
  }
}

export function collect(context: Node): Collector<Node> {
  return new Collector(context);
}

export function closest<T extends Node>(
  context: Node,
  predicate: Predicate<Node, T>
): T | null {
  for (
    let next: Node | null = context;
    next;
    next = isChild(next) ? next.parentNode || null : null
  ) {
    if (predicate(next)) {
      return next as T;
    }
  }

  return null;
}
